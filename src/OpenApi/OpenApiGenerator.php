<?php

namespace Stackmasteraliza\ApiResponse\OpenApi;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Routing\Route;
use Illuminate\Routing\Router;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;
use ReflectionClass;
use ReflectionMethod;
use ReflectionNamedType;
use ReflectionParameter;
use Stackmasteraliza\ApiResponse\Attributes\ApiEndpoint;
use Stackmasteraliza\ApiResponse\Attributes\ApiRequest;
use Stackmasteraliza\ApiResponse\Attributes\ApiRequestBody;
use Stackmasteraliza\ApiResponse\Attributes\ApiResponse;

class OpenApiGenerator
{
    protected array $spec = [];
    protected Router $router;

    public function __construct(Router $router)
    {
        $this->router = $router;
    }

    /**
     * Generate the OpenAPI specification.
     */
    public function generate(): array
    {
        $this->initializeSpec();
        $this->processRoutes();

        return $this->spec;
    }

    /**
     * Generate and save to file.
     */
    public function generateToFile(string $path): bool
    {
        $spec = $this->generate();
        $json = json_encode($spec, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);

        return File::put($path, $json) !== false;
    }

    /**
     * Initialize the OpenAPI specification structure.
     */
    protected function initializeSpec(): void
    {
        $this->spec = [
            'openapi' => '3.0.3',
            'info' => [
                'title' => config('api-response.openapi.title', config('app.name', 'API') . ' Documentation'),
                'description' => config('api-response.openapi.description', 'API documentation generated by Laravel API Response Builder'),
                'version' => config('api-response.openapi.version', '1.0.0'),
                'contact' => config('api-response.openapi.contact', []),
                'license' => config('api-response.openapi.license', []),
            ],
            'servers' => config('api-response.openapi.servers', [
                ['url' => config('app.url', 'http://localhost'), 'description' => 'API Server'],
            ]),
            'paths' => [],
            'components' => [
                'schemas' => $this->getDefaultSchemas(),
                'securitySchemes' => config('api-response.openapi.security_schemes', []),
            ],
            'tags' => [],
        ];

        // Remove empty contact/license
        if (empty($this->spec['info']['contact'])) {
            unset($this->spec['info']['contact']);
        }
        if (empty($this->spec['info']['license'])) {
            unset($this->spec['info']['license']);
        }
        if (empty($this->spec['components']['securitySchemes'])) {
            unset($this->spec['components']['securitySchemes']);
        }
    }

    /**
     * Get default schemas for API responses.
     */
    protected function getDefaultSchemas(): array
    {
        return [
            'SuccessResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 200],
                    'success' => ['type' => 'boolean', 'example' => true],
                    'message' => ['type' => 'string', 'example' => 'Success'],
                    'data' => ['type' => 'object', 'nullable' => true],
                ],
            ],
            'ErrorResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 400],
                    'success' => ['type' => 'boolean', 'example' => false],
                    'message' => ['type' => 'string', 'example' => 'Error'],
                    'errors' => ['type' => 'object', 'nullable' => true],
                ],
            ],
            'PaginatedResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 200],
                    'success' => ['type' => 'boolean', 'example' => true],
                    'message' => ['type' => 'string'],
                    'data' => ['type' => 'array', 'items' => ['type' => 'object']],
                    'meta' => [
                        'type' => 'object',
                        'properties' => [
                            'current_page' => ['type' => 'integer'],
                            'per_page' => ['type' => 'integer'],
                            'total' => ['type' => 'integer'],
                            'last_page' => ['type' => 'integer'],
                            'from' => ['type' => 'integer', 'nullable' => true],
                            'to' => ['type' => 'integer', 'nullable' => true],
                            'path' => ['type' => 'string'],
                            'links' => [
                                'type' => 'object',
                                'properties' => [
                                    'first' => ['type' => 'string', 'nullable' => true],
                                    'last' => ['type' => 'string', 'nullable' => true],
                                    'prev' => ['type' => 'string', 'nullable' => true],
                                    'next' => ['type' => 'string', 'nullable' => true],
                                ],
                            ],
                        ],
                    ],
                ],
            ],
            'ValidationErrorResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 422],
                    'success' => ['type' => 'boolean', 'example' => false],
                    'message' => ['type' => 'string', 'example' => 'Validation failed'],
                    'errors' => [
                        'type' => 'object',
                        'additionalProperties' => [
                            'type' => 'array',
                            'items' => ['type' => 'string'],
                        ],
                    ],
                ],
            ],
        ];
    }

    /**
     * Process all routes and extract documentation.
     */
    protected function processRoutes(): void
    {
        $routes = $this->router->getRoutes();
        $tags = [];
        $prefix = config('api-response.openapi.route_prefix', 'api');

        foreach ($routes as $route) {
            /** @var Route $route */
            $uri = $route->uri();

            // Only process routes with the configured prefix
            if ($prefix && ! str_starts_with($uri, $prefix)) {
                continue;
            }

            // Skip internal routes
            if (str_contains($uri, 'api-docs') || str_contains($uri, 'swagger')) {
                continue;
            }

            $action = $route->getAction();

            // Skip closures
            if (! isset($action['controller'])) {
                continue;
            }

            $controllerAction = $action['controller'];

            if (! str_contains($controllerAction, '@')) {
                continue;
            }

            [$controller, $method] = explode('@', $controllerAction);

            if (! class_exists($controller)) {
                continue;
            }

            try {
                $reflection = new ReflectionMethod($controller, $method);
                $pathSpec = $this->buildPathSpec($route, $reflection);

                if ($pathSpec) {
                    $path = '/' . ltrim($uri, '/');
                    // Convert Laravel route parameters to OpenAPI format
                    $path = preg_replace('/\{(\w+)\?\}/', '{$1}', $path);
                    $path = preg_replace('/\{(\w+)\}/', '{$1}', $path);

                    if (! isset($this->spec['paths'][$path])) {
                        $this->spec['paths'][$path] = [];
                    }

                    foreach ($route->methods() as $httpMethod) {
                        $httpMethod = strtolower($httpMethod);
                        if ($httpMethod === 'head') {
                            continue;
                        }
                        $this->spec['paths'][$path][$httpMethod] = $pathSpec;

                        // Collect tags
                        foreach ($pathSpec['tags'] ?? [] as $tag) {
                            $tags[$tag] = true;
                        }
                    }
                }
            } catch (\ReflectionException $e) {
                continue;
            }
        }

        // Set unique tags
        $this->spec['tags'] = array_map(
            fn($tag) => ['name' => $tag],
            array_keys($tags)
        );
    }

    /**
     * Build the path specification for a route.
     */
    protected function buildPathSpec(Route $route, ReflectionMethod $reflection): ?array
    {
        $attributes = $reflection->getAttributes(ApiEndpoint::class);

        // Auto-generate documentation even without attributes
        $endpoint = null;
        if (! empty($attributes)) {
            $endpoint = $attributes[0]->newInstance();
        }

        $spec = [
            'summary' => $endpoint?->summary ?? $this->generateSummary($reflection, $route),
            'description' => $endpoint?->description ?? $this->generateDescription($reflection, $route),
            'operationId' => $this->generateOperationId($route, $reflection),
            'tags' => $endpoint?->tags ?? $this->inferTags($route),
            'parameters' => $this->extractParameters($route, $reflection),
            'responses' => $this->extractResponses($reflection, $route),
        ];

        if ($endpoint?->deprecated) {
            $spec['deprecated'] = true;
        }

        // Add request body for POST/PUT/PATCH
        $requestBody = $this->extractRequestBody($reflection, $route);
        if ($requestBody) {
            $spec['requestBody'] = $requestBody;
        }

        return $spec;
    }

    /**
     * Generate summary from method name and route.
     */
    protected function generateSummary(ReflectionMethod $reflection, ?Route $route = null): string
    {
        $name = $reflection->getName();
        $className = $reflection->getDeclaringClass()->getShortName();

        // Extract resource name from controller (UserController -> User)
        $resource = str_replace('Controller', '', $className);
        $resourceLower = strtolower($resource);

        // Map common Laravel resource controller methods to descriptive summaries
        $methodMappings = [
            'index' => "List all {$resourceLower}s",
            'show' => "Get a {$resourceLower}",
            'store' => "Create a new {$resourceLower}",
            'create' => "Create a new {$resourceLower}",
            'update' => "Update a {$resourceLower}",
            'destroy' => "Delete a {$resourceLower}",
            'delete' => "Delete a {$resourceLower}",
            'edit' => "Edit a {$resourceLower}",
        ];

        if (isset($methodMappings[$name])) {
            return ucfirst($methodMappings[$name]);
        }

        // Convert camelCase/snake_case to readable words
        $words = preg_replace('/([a-z])([A-Z])/', '$1 $2', $name);
        $words = str_replace('_', ' ', $words);

        // Build a more descriptive summary
        $httpMethod = null;
        if ($route) {
            $methods = $route->methods();
            $httpMethod = strtoupper($methods[0] ?? 'GET');
        }

        $summary = ucfirst(strtolower($words));

        // Add context based on HTTP method if summary is too generic
        if (strlen($summary) < 10 && $httpMethod) {
            $verbMap = [
                'GET' => 'Get',
                'POST' => 'Create',
                'PUT' => 'Update',
                'PATCH' => 'Update',
                'DELETE' => 'Delete',
            ];
            $verb = $verbMap[$httpMethod] ?? $httpMethod;
            $summary = "{$verb} {$resourceLower} - {$summary}";
        }

        return $summary;
    }

    /**
     * Generate description from docblock or route context.
     */
    protected function generateDescription(ReflectionMethod $reflection, ?Route $route = null): string
    {
        // First try to get from docblock
        $docComment = $reflection->getDocComment();
        if ($docComment) {
            // Extract first paragraph from docblock
            preg_match('/\/\*\*\s*\n\s*\*\s*(.+?)(?:\n\s*\*\s*\n|\n\s*\*\s*@)/s', $docComment, $matches);

            if (isset($matches[1])) {
                return trim(preg_replace('/\s*\n\s*\*\s*/', ' ', $matches[1]));
            }
        }

        // Generate description from context
        $name = $reflection->getName();
        $className = $reflection->getDeclaringClass()->getShortName();
        $resource = str_replace('Controller', '', $className);

        $descriptionMappings = [
            'index' => "Retrieve a list of all {$resource} resources. Supports pagination if the response data is paginated.",
            'show' => "Retrieve a single {$resource} by its identifier.",
            'store' => "Create a new {$resource} with the provided data.",
            'create' => "Create a new {$resource} with the provided data.",
            'update' => "Update an existing {$resource} with the provided data.",
            'destroy' => "Permanently delete a {$resource} from the system.",
            'delete' => "Permanently delete a {$resource} from the system.",
        ];

        return $descriptionMappings[$name] ?? '';
    }

    /**
     * Generate operation ID.
     */
    protected function generateOperationId(Route $route, ReflectionMethod $reflection): string
    {
        $className = class_basename($reflection->getDeclaringClass()->getName());
        $methodName = $reflection->getName();

        return lcfirst(str_replace('Controller', '', $className)) . ucfirst($methodName);
    }

    /**
     * Infer tags from route.
     */
    protected function inferTags(Route $route): array
    {
        $uri = $route->uri();
        $parts = explode('/', trim($uri, '/'));

        // Skip 'api' prefix
        if (($parts[0] ?? '') === 'api') {
            array_shift($parts);
        }

        if (! empty($parts[0])) {
            return [ucfirst($parts[0])];
        }

        return ['Default'];
    }

    /**
     * Extract parameters from route and attributes.
     */
    protected function extractParameters(Route $route, ReflectionMethod $reflection): array
    {
        $parameters = [];

        // Extract path parameters from route
        preg_match_all('/\{(\w+)\??\}/', $route->uri(), $matches);
        foreach ($matches[1] as $param) {
            $parameters[] = [
                'name' => $param,
                'in' => 'path',
                'required' => ! str_contains($route->uri(), '{' . $param . '?}'),
                'schema' => ['type' => 'string'],
                'description' => ucfirst($param) . ' parameter',
            ];
        }

        // Extract from ApiRequest attributes
        $requestAttributes = $reflection->getAttributes(ApiRequest::class);
        foreach ($requestAttributes as $attr) {
            $request = $attr->newInstance();
            $param = [
                'name' => $request->name,
                'in' => $request->in,
                'required' => $request->required,
                'schema' => ['type' => $request->type],
            ];

            if ($request->description) {
                $param['description'] = $request->description;
            }

            if ($request->example !== null) {
                $param['example'] = $request->example;
            }

            $parameters[] = $param;
        }

        return $parameters;
    }

    /**
     * Extract request body from attributes or FormRequest.
     */
    protected function extractRequestBody(ReflectionMethod $reflection, Route $route): ?array
    {
        $methods = array_map('strtoupper', $route->methods());
        $needsBody = array_intersect($methods, ['POST', 'PUT', 'PATCH']);

        if (empty($needsBody)) {
            return null;
        }

        // First check for ApiRequestBody attribute
        $attributes = $reflection->getAttributes(ApiRequestBody::class);

        if (! empty($attributes)) {
            $body = $attributes[0]->newInstance();

            $schema = [
                'type' => 'object',
                'properties' => [],
            ];

            foreach ($body->properties as $name => $type) {
                $schema['properties'][$name] = $this->parsePropertyType($type);
            }

            if (! empty($body->required)) {
                $schema['required'] = $body->required;
            }

            $requestBody = [
                'required' => true,
                'content' => [
                    'application/json' => [
                        'schema' => $schema,
                    ],
                ],
            ];

            if ($body->description) {
                $requestBody['description'] = $body->description;
            }

            if ($body->example) {
                $requestBody['content']['application/json']['example'] = $body->example;
            }

            return $requestBody;
        }

        // Auto-detect FormRequest in method parameters
        $formRequestSchema = $this->extractFormRequestSchema($reflection);
        if ($formRequestSchema) {
            return $formRequestSchema;
        }

        // Auto-generate basic request body for POST/PUT/PATCH
        return [
            'required' => false,
            'content' => [
                'application/json' => [
                    'schema' => [
                        'type' => 'object',
                        'additionalProperties' => true,
                    ],
                ],
            ],
        ];
    }

    /**
     * Extract schema from FormRequest validation rules.
     */
    protected function extractFormRequestSchema(ReflectionMethod $reflection): ?array
    {
        foreach ($reflection->getParameters() as $parameter) {
            $type = $parameter->getType();

            if (! $type instanceof ReflectionNamedType || $type->isBuiltin()) {
                continue;
            }

            $className = $type->getName();

            if (! class_exists($className)) {
                continue;
            }

            try {
                $classReflection = new ReflectionClass($className);

                if (! $classReflection->isSubclassOf(FormRequest::class)) {
                    continue;
                }

                // Try to extract rules from the FormRequest
                $rules = $this->extractFormRequestRules($classReflection);

                if (empty($rules)) {
                    continue;
                }

                return $this->buildSchemaFromRules($rules, $classReflection);
            } catch (\ReflectionException $e) {
                continue;
            }
        }

        return null;
    }

    /**
     * Extract validation rules from FormRequest class.
     */
    protected function extractFormRequestRules(ReflectionClass $classReflection): array
    {
        // Try to instantiate and get rules
        try {
            // Check if rules method exists
            if (! $classReflection->hasMethod('rules')) {
                return [];
            }

            $rulesMethod = $classReflection->getMethod('rules');

            // Try to get rules from source code analysis (safer than instantiation)
            $source = $this->getMethodSource($rulesMethod);
            $rules = $this->parseRulesFromSource($source);

            if (! empty($rules)) {
                return $rules;
            }

            // Fallback: try to create instance (may not work for all FormRequests)
            $className = $classReflection->getName();
            $instance = new $className();

            if (method_exists($instance, 'rules')) {
                return $instance->rules();
            }
        } catch (\Throwable $e) {
            // Ignore errors and return empty
        }

        return [];
    }

    /**
     * Get method source code.
     */
    protected function getMethodSource(ReflectionMethod $method): string
    {
        $filename = $method->getFileName();
        $startLine = $method->getStartLine();
        $endLine = $method->getEndLine();

        if (! $filename || ! file_exists($filename)) {
            return '';
        }

        $lines = file($filename);
        $length = $endLine - $startLine + 1;

        return implode('', array_slice($lines, $startLine - 1, $length));
    }

    /**
     * Parse validation rules from source code.
     */
    protected function parseRulesFromSource(string $source): array
    {
        $rules = [];

        // Match array key => value patterns like 'field' => 'required|string'
        // or 'field' => ['required', 'string']
        preg_match_all("/['\"](\w+(?:\.\*?)?)['\"]\\s*=>\\s*(?:['\"]([^'\"]+)['\"]|\\[([^\\]]+)\\])/", $source, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $field = $match[1];
            $ruleString = $match[2] ?? $match[3] ?? '';

            // Skip nested/wildcard fields for now
            if (str_contains($field, '.')) {
                continue;
            }

            if (! empty($ruleString)) {
                // Parse pipe-separated rules or array items
                if (str_contains($ruleString, '|')) {
                    $rules[$field] = explode('|', $ruleString);
                } else {
                    // Array format: 'required', 'string', etc.
                    preg_match_all("/['\"]([^'\"]+)['\"]/", $ruleString, $ruleMatches);
                    $rules[$field] = $ruleMatches[1] ?? [$ruleString];
                }
            }
        }

        return $rules;
    }

    /**
     * Build OpenAPI schema from validation rules.
     */
    protected function buildSchemaFromRules(array $rules, ReflectionClass $classReflection): array
    {
        $properties = [];
        $required = [];

        foreach ($rules as $field => $fieldRules) {
            if (is_string($fieldRules)) {
                $fieldRules = explode('|', $fieldRules);
            }

            $property = $this->convertRulesToSchema($fieldRules);
            $properties[$field] = $property;

            // Check if required
            if (in_array('required', $fieldRules, true)) {
                $required[] = $field;
            }
        }

        $schema = [
            'type' => 'object',
            'properties' => $properties,
        ];

        if (! empty($required)) {
            $schema['required'] = $required;
        }

        $requestBody = [
            'required' => true,
            'content' => [
                'application/json' => [
                    'schema' => $schema,
                ],
            ],
        ];

        // Add description from class docblock
        $docComment = $classReflection->getDocComment();
        if ($docComment) {
            preg_match('/\/\*\*\s*\n\s*\*\s*(.+?)(?:\n\s*\*\s*\n|\n\s*\*\s*@)/s', $docComment, $matches);
            if (isset($matches[1])) {
                $requestBody['description'] = trim(preg_replace('/\s*\n\s*\*\s*/', ' ', $matches[1]));
            }
        }

        return $requestBody;
    }

    /**
     * Convert Laravel validation rules to OpenAPI schema.
     */
    protected function convertRulesToSchema(array $rules): array
    {
        $schema = ['type' => 'string'];

        foreach ($rules as $rule) {
            $rule = is_string($rule) ? $rule : '';
            $ruleLower = strtolower($rule);

            // Type detection
            if (in_array($ruleLower, ['integer', 'int', 'numeric'])) {
                $schema['type'] = 'integer';
            } elseif (in_array($ruleLower, ['boolean', 'bool'])) {
                $schema['type'] = 'boolean';
            } elseif ($ruleLower === 'array') {
                $schema['type'] = 'array';
                $schema['items'] = ['type' => 'string'];
            } elseif ($ruleLower === 'json' || $ruleLower === 'object') {
                $schema['type'] = 'object';
            } elseif (in_array($ruleLower, ['decimal', 'numeric'])) {
                $schema['type'] = 'number';
            }

            // Format detection
            if ($ruleLower === 'email') {
                $schema['format'] = 'email';
            } elseif ($ruleLower === 'url') {
                $schema['format'] = 'uri';
            } elseif ($ruleLower === 'date') {
                $schema['format'] = 'date';
            } elseif (str_starts_with($ruleLower, 'date_format:')) {
                $schema['format'] = 'date-time';
            } elseif ($ruleLower === 'uuid') {
                $schema['format'] = 'uuid';
            } elseif ($ruleLower === 'ip' || $ruleLower === 'ipv4') {
                $schema['format'] = 'ipv4';
            } elseif ($ruleLower === 'ipv6') {
                $schema['format'] = 'ipv6';
            }

            // Constraints
            if (str_starts_with($ruleLower, 'min:')) {
                $min = (int) substr($rule, 4);
                if ($schema['type'] === 'string') {
                    $schema['minLength'] = $min;
                } elseif (in_array($schema['type'], ['integer', 'number'])) {
                    $schema['minimum'] = $min;
                }
            } elseif (str_starts_with($ruleLower, 'max:')) {
                $max = (int) substr($rule, 4);
                if ($schema['type'] === 'string') {
                    $schema['maxLength'] = $max;
                } elseif (in_array($schema['type'], ['integer', 'number'])) {
                    $schema['maximum'] = $max;
                }
            } elseif (str_starts_with($ruleLower, 'in:')) {
                $values = explode(',', substr($rule, 3));
                $schema['enum'] = $values;
            } elseif (str_starts_with($ruleLower, 'regex:')) {
                $pattern = substr($rule, 6);
                // Clean up regex delimiters
                $pattern = preg_replace('/^\/(.+)\/[a-z]*$/', '$1', $pattern);
                $schema['pattern'] = $pattern;
            }

            // Nullable
            if ($ruleLower === 'nullable') {
                $schema['nullable'] = true;
            }
        }

        return $schema;
    }

    /**
     * Parse property type to OpenAPI schema.
     */
    protected function parsePropertyType(mixed $type): array
    {
        if (is_array($type)) {
            return $type;
        }

        return match ($type) {
            'int', 'integer' => ['type' => 'integer'],
            'float', 'double', 'number' => ['type' => 'number'],
            'bool', 'boolean' => ['type' => 'boolean'],
            'array' => ['type' => 'array', 'items' => ['type' => 'string']],
            'object' => ['type' => 'object'],
            default => ['type' => 'string'],
        };
    }

    /**
     * Extract responses from attributes or infer from method.
     */
    protected function extractResponses(ReflectionMethod $reflection, Route $route): array
    {
        $responses = [];

        // Check for ApiResponse attributes
        $responseAttributes = $reflection->getAttributes(ApiResponse::class);

        if (! empty($responseAttributes)) {
            foreach ($responseAttributes as $attr) {
                $response = $attr->newInstance();
                $responses[(string) $response->status] = $this->buildResponseSpec($response);
            }
        }

        // Auto-infer responses if none specified
        if (empty($responses)) {
            $responses = $this->inferResponses($reflection, $route);
        }

        return $responses;
    }

    /**
     * Build response specification.
     */
    protected function buildResponseSpec(ApiResponse $response): array
    {
        $spec = [
            'description' => $response->description,
        ];

        if ($response->ref) {
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['$ref' => '#/components/schemas/' . $response->ref],
                ],
            ];
        } elseif ($response->example) {
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['type' => 'object'],
                    'example' => $response->example,
                ],
            ];
        } else {
            $schemaRef = $this->getSchemaRefForStatus($response->status);
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['$ref' => '#/components/schemas/' . $schemaRef],
                ],
            ];
        }

        return $spec;
    }

    /**
     * Get schema reference for status code.
     */
    protected function getSchemaRefForStatus(int $status): string
    {
        return match (true) {
            $status >= 200 && $status < 300 => 'SuccessResponse',
            $status === 422 => 'ValidationErrorResponse',
            $status >= 400 => 'ErrorResponse',
            default => 'SuccessResponse',
        };
    }

    /**
     * Infer responses from method analysis.
     */
    protected function inferResponses(ReflectionMethod $reflection, Route $route): array
    {
        $methodName = strtolower($reflection->getName());
        $httpMethods = array_map('strtoupper', $route->methods());

        // First, try to detect ApiResponse method calls from source code
        $sourceResponses = $this->detectApiResponseCalls($reflection);
        if (! empty($sourceResponses)) {
            return $sourceResponses;
        }

        // Fallback: Analyze method name and HTTP method to infer responses
        $responses = [];

        // Success response based on method name
        if (str_contains($methodName, 'store') || str_contains($methodName, 'create')) {
            $responses['201'] = [
                'description' => 'Resource created successfully',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        } elseif (str_contains($methodName, 'destroy') || str_contains($methodName, 'delete')) {
            $responses['204'] = [
                'description' => 'Resource deleted successfully',
            ];
        } elseif (str_contains($methodName, 'paginate')) {
            $responses['200'] = [
                'description' => 'Paginated results',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/PaginatedResponse'],
                    ],
                ],
            ];
        } else {
            $responses['200'] = [
                'description' => 'Successful response',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        }

        // Add common error responses
        if (str_contains($methodName, 'validation') || in_array('POST', $httpMethods) || in_array('PUT', $httpMethods)) {
            $responses['422'] = [
                'description' => 'Validation error',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ValidationErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'unauthorized')) {
            $responses['401'] = [
                'description' => 'Unauthorized',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'forbidden')) {
            $responses['403'] = [
                'description' => 'Forbidden',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'notfound') || str_contains($methodName, 'not_found')) {
            $responses['404'] = [
                'description' => 'Resource not found',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'badrequest') || str_contains($methodName, 'bad_request')) {
            $responses['400'] = [
                'description' => 'Bad request',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'servererror') || str_contains($methodName, 'server_error')) {
            $responses['500'] = [
                'description' => 'Internal server error',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'ratelimit') || str_contains($methodName, 'rate_limit')) {
            $responses['429'] = [
                'description' => 'Too many requests',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'conflict')) {
            $responses['409'] = [
                'description' => 'Conflict',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'async') || str_contains($methodName, 'accepted')) {
            $responses['202'] = [
                'description' => 'Request accepted for processing',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        }

        return $responses;
    }

    /**
     * Detect ApiResponse method calls from source code.
     */
    protected function detectApiResponseCalls(ReflectionMethod $reflection): array
    {
        $source = $this->getMethodSource($reflection);
        $responses = [];

        // Map of ApiResponse methods to their status codes and descriptions
        $methodMapping = [
            'success' => ['status' => 200, 'description' => 'Successful response', 'schema' => 'SuccessResponse'],
            'created' => ['status' => 201, 'description' => 'Resource created successfully', 'schema' => 'SuccessResponse'],
            'accepted' => ['status' => 202, 'description' => 'Request accepted for processing', 'schema' => 'SuccessResponse'],
            'noContent' => ['status' => 204, 'description' => 'No content'],
            'badRequest' => ['status' => 400, 'description' => 'Bad request', 'schema' => 'ErrorResponse'],
            'unauthorized' => ['status' => 401, 'description' => 'Unauthorized', 'schema' => 'ErrorResponse'],
            'forbidden' => ['status' => 403, 'description' => 'Forbidden', 'schema' => 'ErrorResponse'],
            'notFound' => ['status' => 404, 'description' => 'Resource not found', 'schema' => 'ErrorResponse'],
            'methodNotAllowed' => ['status' => 405, 'description' => 'Method not allowed', 'schema' => 'ErrorResponse'],
            'conflict' => ['status' => 409, 'description' => 'Conflict', 'schema' => 'ErrorResponse'],
            'unprocessable' => ['status' => 422, 'description' => 'Unprocessable entity', 'schema' => 'ValidationErrorResponse'],
            'validationError' => ['status' => 422, 'description' => 'Validation failed', 'schema' => 'ValidationErrorResponse'],
            'tooManyRequests' => ['status' => 429, 'description' => 'Too many requests', 'schema' => 'ErrorResponse'],
            'serverError' => ['status' => 500, 'description' => 'Internal server error', 'schema' => 'ErrorResponse'],
            'serviceUnavailable' => ['status' => 503, 'description' => 'Service unavailable', 'schema' => 'ErrorResponse'],
        ];

        // Detect ApiResponse::method() or $this->method() calls
        foreach ($methodMapping as $method => $config) {
            // Match patterns like: ApiResponse::success, $this->success, ->success(
            $patterns = [
                "/ApiResponse::{$method}\s*\(/i",
                "/\\\$this->{$method}\s*\(/i",
                "/->\\s*{$method}\s*\(/i",
            ];

            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $source)) {
                    $statusCode = (string) $config['status'];

                    if (! isset($responses[$statusCode])) {
                        $response = ['description' => $config['description']];

                        if (isset($config['schema'])) {
                            $response['content'] = [
                                'application/json' => [
                                    'schema' => ['$ref' => '#/components/schemas/' . $config['schema']],
                                ],
                            ];
                        }

                        $responses[$statusCode] = $response;
                    }

                    break;
                }
            }
        }

        // Detect paginate() calls for paginated responses
        if (preg_match('/->paginate\s*\(|->cursorPaginate\s*\(/i', $source)) {
            $responses['200'] = [
                'description' => 'Paginated results',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/PaginatedResponse'],
                    ],
                ],
            ];
        }

        return $responses;
    }
}
